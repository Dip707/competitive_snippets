{
    "Header files and macros and typedefs":{
        "prefix": "!!basics",
        "body": [
            "#include <bits/stdc++.h>",
            "//For ordered_set",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "#define MOD 1000000007",
            "#define test int t; cin>>t; while(t--)",
            "#define init(arr,val) memset(arr,val,sizeof(arr))",
            "#define loop(i,a,b) for(int i=a;i<b;i++)",
            "#define loopr(i,a,b) for(int i=a;i>=b;i--)",
            "#define loops(i,a,b,step) for(int i=a;i<b;i+=step)",
            "#define looprs(i,a,b,step) for(int i=a;i>=b;i-=step)",
            "#define ull unsigned long long int",
            "#define ll long long int",
            "#define P pair",
            "#define PLL pair<long long, long long>",
            "#define PII pair<int, int>",
            "#define PUU pair<unsigned long long int, unsigned long long int>",
            "#define L list",
            "#define V vector",
            "#define D deque",
            "#define ST set",
            "#define MS multiset",
            "#define M map",
            "#define UM unordered_map",
            "#define mp make_pair",
            "#define pb push_back",
            "#define pf push_front",
            "#define MM multimap",
            "#define F first",
            "#define S second",
            "#define IT iterator",
            "#define RIT reverse_iterator",
            "#define FAST ios_base::sync_with_stdio(false);cin.tie();cout.tie();",
            "#define FILE_READ_IN freopen(\"input.txt\",\"r\",stdin);",
            "#define FILE_READ_OUT freopen(\"output.txt\",\"w\",stdout);",
            "#define all(a) a.begin(),a.end()",
            "using namespace std;",
            "// For ordered_set",
            "using namespace __gnu_pbds;",
            "template <typename T>",
            "using ord_set = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;",
            "const ll maxn = 1e5;",
            "const ll inf = 1e9;",
            "const double pi = acos(-1);"
        ],
        "description":"Generates all the major macros used in competitive programming and new useful macros will be added with time"
    },
    "Maximum Node Segment Tree":{
        "prefix": "!!max_seg_tree",
        "body":[
            "vector<int> seg_tree;",
            "vector<int> lazy;",
            "void build(int node = 0, int start = 0, int end = N){",
            "    if(start == end){",
            "        seg_tree[node] = arr[node];",
            "        return;",
            "    }",
            "    build(2*node+1,start,(start+end)/2);",
            "    build(2*node+2,(start+end)/2+1,end);",
            "    seg_tree[node] = max(seg_tree[2*node+1],seg_tree[2*node+2]);",
            "}",
            " ",
            "void update(int l, int r, int val, int node = 0, int start = 0, int end = N){",
            "    //Remove this if part if lazy not required",
            "    if(lazy[node] != 0){",
            "        seg_tree[node] += lazy[node];",
            "        if(start != end){",
            "            lazy[2*node+1] += lazy[node];",
            "            lazy[2*node+2] += lazy[node];",
            "        }",
            "        lazy[node] = 0;",
            "    }",
            "    if(l > end || r < start)return;",
            "    if(l <= start && end <= start){",
            "        seg_tree[node] += val;",
            "        if(start != end){",
            "            lazy[2*node+1] += val;",
            "            lazy[2*node+2] += val;",
            "        }",
            "        return;",
            "    }",
            "    update(l,r,val,2*node+1,start,(start+end)/2);",
            "    update(l,r,val,2*node+2,(start+end)/2+1,end);",
            "}",
            " ",
            "int query(int l, int r, int node = 0, int start = 0, int end = N){",
            "    //Remove this if part if lazy not required",
            "    if(lazy[node] != 0){",
            "        seg_tree[node] += lazy[node];",
            "        if(start != end){",
            "            lazy[2*node+1] += lazy[node];",
            "            lazy[2*node+2] += lazy[node];",
            "        }",
            "        lazy[node] = 0;",
            "    }",
            "    if(l > end || r < start)return inf;",
            "    if(l <= start && end <= start)return seg_tree[node];",
            "    return max(query(l,r,2*node+1,start,(start+end)/2),query(l,r,2*node+2,(start+end)/2+1,end));",
            "}"
        ],
        "description": "Will generate a basic working segment tree code for building, updating and querying the maximum in Range Maximum Query in Lazy Propogation"
    },
    "Disjoint Set Unions":{
        "prefix": "!!dsu",
        "body":[
            "vector<int> Rank;",
            "vector<int> parent;",
            "int findParent(int x){",
            "    while(x != parent[x]){",
            "        parent[x] = parent[parent[x]];",
            "        x = parent[x];",
            "    }",
            "}",
            "void UNION(int a, int b){",
            "    a = findParent(a);",
            "    b = findParent(b);",
            "    if(Rank[a] < Rank[b]){",
            "        parent[a]=b;",
            "    }else if(Rank[a] > Rank[b]){",
            "        parent[b] = a;",
            "    }else{",
            "        parent[a] = b;",
            "        Rank[b]++;",
            "    }",
            "}"
        ],
        "description": "Disjoint Set Union Code to Import basic Disjoint set Snippet"
    }
}